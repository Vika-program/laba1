# Лаба 1: Калькулятор (сложность M2)

## Запуск программы
python -m src.main

## Запуск тестов
uv run python -m pytest

## Формат ввода
* Выражение вводится в инфиксной записи
* Доступны операторы +, -, *, /, //, **, %
* На ноль делить нельзя
* Операторы %, // только для целых чисел
* Поддерживаются унарные операторы +, - (они должны быть записаны в отдельных скобках, если перед ними есть другой оператор)
* Выражение корректно считается и с пробелами, и без них
* Токен нельзя разделять пробелом
* Все открытые скобки долны быть закрыты
* В скобках может быть одно число
* Строка дожна представлять собой корректное математическое выражение, не допустимы такие записи: "1 1 + ", "1 +", "*1" и т. д.
* При неправильном вводе выдаются сообщения об ошибке
* Чтобы завершить программу, нужно нажать enter

## Принятые решения

1. #### Теперь опишу структуру кода:
* В файле **_other_** хранятся вспомогательные функции is_op, is_num, is_un и класс ошибок CalcError
* В файле **_tokenize_** хранится функция tokenize_
* В файле **_is_correct_** хранится функция is_correct
* В файле **_trans_** хранится функция trans_to_rpn
* В файле **_calc_** хранится функция calc
* В файле **_main_** выполняется сама программа

_Примечание:_ в моем коде функции вложены друг в друга

2. Чтобы отличать унарные операторы от обычных, я создала функцию is_un, где
оператор проверяется на унарность, и если значение функции истина,
то добавляю слева "u" к оператору при токенизации.

3. Чтобы проверить правильность расставления скобок, используется счётчик
open_brackets, который мы увеличиваем, если видим открытую скобку, и уменьшаем, если закрытую.
В конце счётчик должен быть равен нулю, если выражение записано верно.


4. Я решила выводить в ответе всегда тип int, если дробная часть равна нулю


5. Проверка корректности выражения чаcтично происходит в функции is_correct,
а остальное обрабатывается в функции calc.

## Алгоритм

### Токенизация

Проходимся по строке, если видим цифру, то начинаем собирать число
(добавляем цифры и точку), если видим другой символ, то добавляем число
в new_expr и сбрасываем его, а затем добаляем в new_expr другой символ. Если видим пробел, ничего не делаем. В конце добавляем
текущее число в new_expr.

### Проверка выражения
Если найдет недопустимый символ или точка стоит неверно - выводим ошибку.
Если два числа идут подряд или неверно расставлены скобки - делаем то же самое.
Другие ошибки можно обработать на этапе вычисления.

### Перевод выражения в польскую запись
Проходимся по токенам, если видим число - добавляем в список res,
если операцию, то:
* Если это возведение в степень, то пока последний символ является операцией
и выше или равен по приоритету последнему в op_trans, добавляем текущий токен в
список res, удаляя из op_trans.
* Иначе, пока op_trans не пустой список, последний символ является операцией
и выше по приоритету, чем последний в op_trans, добавляем операцию в список res.
Затем добавляем в список op_trans токен.
Если видим открывающую скобку - добавляем в op_trans,
если закрывающую, то, пока не увидим открывающую скобку,
добавляем всё в res, удаляя из op_trans, потом удаляем открывающую скобку.
В конце добавляем оставшиеся операции и возвращаем список res.

### Вычисление
Проходимся по токенам в польской записи, если видим число, приводим к float и
добавляем в stack, если операцию - вычисляем значение (если в stack не меньше 2 элементов, иначе выводим ошибку)
и добавляем его в stack. В функции обрабатываем
исключения (деление на ноль и ограничения операций %, //). В конце удаляем элемент из stack и выводим ответ,
если stack пустой, иначе - ошибку.

## Допущения
* Допустимы лишние скобки, если они все парные и не противоречат правилам
* Допустимы лишние пробелы
* Допустимо ввести одно число, тогда программа его и вернёт

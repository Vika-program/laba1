# Лаба 1: Калькулятор (сложность M2)

## Запуск программы
python -m src.main

## Запуск тестов
uv run python -m pytest

## Формат ввода
* Выражение вводится в инфиксной записи
* Доступны операторы +, -, *, /, //, **, %
* На ноль делить нельзя
* Операторы %, // только для целых чисел
* Поддерживаются унарные операторы +, - (они должны быть записаны в отдельных скобках, если перед ними есть другой оператор)
* Выражение корректно считается и с пробелами, и без них
* Токен нельзя разделять пробелом
* Все открытые скобки долны быть закрыты
* В скобках может быть одно число
* Строка дожна представлять собой корректное математическое выражение, не допустимы такие записи: "1 1 + ", "1 +", "*1" и т. д.
* При неправильном вводе выдаются сообщения об ошибке
* Чтобы завершить программу, нужно нажать enter

## Принятые решения

1. #### Теперь опишу структуру кода:
* В файле **_other_** хранятся вспомогательные функции is_op, is_num, is_un и класс ошибок CalcError
* В файле **_tokenize_2_** хранится функция tokenize_2
* В файле **_trans_** хранится функция trans_to_rpn
* В файле **_calc_** хранится функция calc
* В файле **_main_** выполняется сама программа

_Примечание:_ в моем коде функции вложены друг в друга

2. Пользователь может вводить выражение как с пробелами, так и без них, поэтому при токенизации я сама добавляю пробелы,
где нужно, чтобы потом по ним разделить строку.


3. Чтобы отличать унарные операторы от обычных, я создала функцию is_un, где
оператор проверяется на унарность, и если значение функции истина,
то добавляю слева "u" к оператору при токенизации.


4. Чтобы проверить правильность расставления скобок, используется счётчик
open_brackets, который мы увеличиваем, если видим открытую скобку, и уменьшаем, если закрытую.
В конце счётчик должен быть равен нулю, если выражение записано верно.


5. Я решила выводить в ответе всегда тип int, если дробная часть равна нулю

## Алгоритм

### Токенизация

Проверяем, что выражение корректно (правильно расставлены скобки, два числа и две
операции не идут подряд, нет лишних символов, последний токен не является оператором), параллельно
доставляем пробелы между токенами, потом разделяем по ним строку.
(Комментарии есть в коде)


### Перевод выражения в польскую запись
Проходимся по токенам, если видим число - добавляем в список res,
если операцию, то:
* Если это возведение в степень, то пока последний символ является операцией
и выше или равен по приоритету последнему в op_trans, добавляем текущий токен в
список res, удаляя из op_trans.
* Иначе, пока op_trans не пустой список, последний символ является операцией
и выше по приоритету, чем последний в op_trans, добавляем операцию в список res.
Затем добавляем в список op_trans токен.
Если видим открывающую скобку - добавляем в op_trans,
если закрывающую, то, пока не увидим открывающую скобку,
добавляем всё в res, удаляя из op_trans, потом удаляем открывающую скобку.
В конце добавляем оставшиеся операции и возвращаем список res.

### Вычисление
Проходимся по токенам в польской записи, если видим число, приводим к float и
добавляем в stack, если операцию - вычисляем значение
и добавляем его в stack. В функции обрабатываем
исключения (деление на ноль и ограничения операций %, //) и выводим ответ.

## Допущения
* Допустимы лишние скобки, если они все парные и не противоречат правилам
* Допустимы лишние пробелы
* Допустимо ввести одно число, тогда программа его и вернёт
